{
  "version": 3,
  "sources": ["../../three/examples/jsm/loaders/STLLoader.js"],
  "sourcesContent": ["import {\r\n\tBufferAttribute,\r\n\tBufferGeometry,\r\n\tFileLoader,\r\n\tFloat32BufferAttribute,\r\n\tLoader,\r\n\tVector3\r\n} from 'three';\r\n\r\n/**\r\n * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\r\n *\r\n * Supports both binary and ASCII encoded files, with automatic detection of type.\r\n *\r\n * The loader returns a non-indexed buffer geometry.\r\n *\r\n * Limitations:\r\n *  Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\r\n *  There is perhaps some question as to how valid it is to always assume little-endian-ness.\r\n *  ASCII decoding assumes file is UTF-8.\r\n *\r\n * Usage:\r\n *  const loader = new STLLoader();\r\n *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {\r\n *    scene.add( new THREE.Mesh( geometry ) );\r\n *  });\r\n *\r\n * For binary STLs geometry might contain colors for vertices. To use it:\r\n *  // use the same code to load STL as above\r\n *  if (geometry.hasColors) {\r\n *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: true });\r\n *  } else { .... }\r\n *  const mesh = new THREE.Mesh( geometry, material );\r\n *\r\n * For ASCII STLs containing multiple solids, each solid is assigned to a different group.\r\n * Groups can be used to assign a different color by defining an array of materials with the same length of\r\n * geometry.groups and passing it to the Mesh constructor:\r\n *\r\n * const mesh = new THREE.Mesh( geometry, material );\r\n *\r\n * For example:\r\n *\r\n *  const materials = [];\r\n *  const nGeometryGroups = geometry.groups.length;\r\n *\r\n *  const colorMap = ...; // Some logic to index colors.\r\n *\r\n *  for (let i = 0; i < nGeometryGroups; i++) {\r\n *\r\n *\t\tconst material = new THREE.MeshPhongMaterial({\r\n *\t\t\tcolor: colorMap[i],\r\n *\t\t\twireframe: false\r\n *\t\t});\r\n *\r\n *  }\r\n *\r\n *  materials.push(material);\r\n *  const mesh = new THREE.Mesh(geometry, materials);\r\n */\r\n\r\n\r\nclass STLLoader extends Loader {\r\n\r\n\tconstructor( manager ) {\r\n\r\n\t\tsuper( manager );\r\n\r\n\t}\r\n\r\n\tload( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tconst loader = new FileLoader( this.manager );\r\n\t\tloader.setPath( this.path );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\tloader.setRequestHeader( this.requestHeader );\r\n\t\tloader.setWithCredentials( this.withCredentials );\r\n\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\tonLoad( scope.parse( text ) );\r\n\r\n\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\tif ( onError ) {\r\n\r\n\t\t\t\t\tonError( e );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.error( e );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t\t}\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t}\r\n\r\n\tparse( data ) {\r\n\r\n\t\tfunction isBinary( data ) {\r\n\r\n\t\t\tconst reader = new DataView( data );\r\n\t\t\tconst face_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 );\r\n\t\t\tconst n_faces = reader.getUint32( 80, true );\r\n\t\t\tconst expect = 80 + ( 32 / 8 ) + ( n_faces * face_size );\r\n\r\n\t\t\tif ( expect === reader.byteLength ) {\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// An ASCII STL data must begin with 'solid ' as the first six bytes.\r\n\t\t\t// However, ASCII STLs lacking the SPACE after the 'd' are known to be\r\n\t\t\t// plentiful.  So, check the first 5 bytes for 'solid'.\r\n\r\n\t\t\t// Several encodings, such as UTF-8, precede the text with up to 5 bytes:\r\n\t\t\t// https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\r\n\t\t\t// Search for \"solid\" to start anywhere after those prefixes.\r\n\r\n\t\t\t// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\r\n\r\n\t\t\tconst solid = [ 115, 111, 108, 105, 100 ];\r\n\r\n\t\t\tfor ( let off = 0; off < 5; off ++ ) {\r\n\r\n\t\t\t\t// If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\r\n\r\n\t\t\t\tif ( matchDataViewAt( solid, reader, off ) ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Couldn't find \"solid\" text at the beginning; it is binary STL.\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\tfunction matchDataViewAt( query, reader, offset ) {\r\n\r\n\t\t\t// Check if each byte in query matches the corresponding byte from the current offset\r\n\r\n\t\t\tfor ( let i = 0, il = query.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tif ( query[ i ] !== reader.getUint8( offset + i ) ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseBinary( data ) {\r\n\r\n\t\t\tconst reader = new DataView( data );\r\n\t\t\tconst faces = reader.getUint32( 80, true );\r\n\r\n\t\t\tlet r, g, b, hasColors = false, colors;\r\n\t\t\tlet defaultR, defaultG, defaultB, alpha;\r\n\r\n\t\t\t// process STL header\r\n\t\t\t// check for default color in header (\"COLOR=rgba\" sequence).\r\n\r\n\t\t\tfor ( let index = 0; index < 80 - 10; index ++ ) {\r\n\r\n\t\t\t\tif ( ( reader.getUint32( index, false ) == 0x434F4C4F /*COLO*/ ) &&\r\n\t\t\t\t\t( reader.getUint8( index + 4 ) == 0x52 /*'R'*/ ) &&\r\n\t\t\t\t\t( reader.getUint8( index + 5 ) == 0x3D /*'='*/ ) ) {\r\n\r\n\t\t\t\t\thasColors = true;\r\n\t\t\t\t\tcolors = new Float32Array( faces * 3 * 3 );\r\n\r\n\t\t\t\t\tdefaultR = reader.getUint8( index + 6 ) / 255;\r\n\t\t\t\t\tdefaultG = reader.getUint8( index + 7 ) / 255;\r\n\t\t\t\t\tdefaultB = reader.getUint8( index + 8 ) / 255;\r\n\t\t\t\t\talpha = reader.getUint8( index + 9 ) / 255;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst dataOffset = 84;\r\n\t\t\tconst faceLength = 12 * 4 + 2;\r\n\r\n\t\t\tconst geometry = new BufferGeometry();\r\n\r\n\t\t\tconst vertices = new Float32Array( faces * 3 * 3 );\r\n\t\t\tconst normals = new Float32Array( faces * 3 * 3 );\r\n\r\n\t\t\tfor ( let face = 0; face < faces; face ++ ) {\r\n\r\n\t\t\t\tconst start = dataOffset + face * faceLength;\r\n\t\t\t\tconst normalX = reader.getFloat32( start, true );\r\n\t\t\t\tconst normalY = reader.getFloat32( start + 4, true );\r\n\t\t\t\tconst normalZ = reader.getFloat32( start + 8, true );\r\n\r\n\t\t\t\tif ( hasColors ) {\r\n\r\n\t\t\t\t\tconst packedColor = reader.getUint16( start + 48, true );\r\n\r\n\t\t\t\t\tif ( ( packedColor & 0x8000 ) === 0 ) {\r\n\r\n\t\t\t\t\t\t// facet has its own unique color\r\n\r\n\t\t\t\t\t\tr = ( packedColor & 0x1F ) / 31;\r\n\t\t\t\t\t\tg = ( ( packedColor >> 5 ) & 0x1F ) / 31;\r\n\t\t\t\t\t\tb = ( ( packedColor >> 10 ) & 0x1F ) / 31;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tr = defaultR;\r\n\t\t\t\t\t\tg = defaultG;\r\n\t\t\t\t\t\tb = defaultB;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( let i = 1; i <= 3; i ++ ) {\r\n\r\n\t\t\t\t\tconst vertexstart = start + i * 12;\r\n\t\t\t\t\tconst componentIdx = ( face * 3 * 3 ) + ( ( i - 1 ) * 3 );\r\n\r\n\t\t\t\t\tvertices[ componentIdx ] = reader.getFloat32( vertexstart, true );\r\n\t\t\t\t\tvertices[ componentIdx + 1 ] = reader.getFloat32( vertexstart + 4, true );\r\n\t\t\t\t\tvertices[ componentIdx + 2 ] = reader.getFloat32( vertexstart + 8, true );\r\n\r\n\t\t\t\t\tnormals[ componentIdx ] = normalX;\r\n\t\t\t\t\tnormals[ componentIdx + 1 ] = normalY;\r\n\t\t\t\t\tnormals[ componentIdx + 2 ] = normalZ;\r\n\r\n\t\t\t\t\tif ( hasColors ) {\r\n\r\n\t\t\t\t\t\tcolors[ componentIdx ] = r;\r\n\t\t\t\t\t\tcolors[ componentIdx + 1 ] = g;\r\n\t\t\t\t\t\tcolors[ componentIdx + 2 ] = b;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );\r\n\t\t\tgeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\r\n\r\n\t\t\tif ( hasColors ) {\r\n\r\n\t\t\t\tgeometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );\r\n\t\t\t\tgeometry.hasColors = true;\r\n\t\t\t\tgeometry.alpha = alpha;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn geometry;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseASCII( data ) {\r\n\r\n\t\t\tconst geometry = new BufferGeometry();\r\n\t\t\tconst patternSolid = /solid([\\s\\S]*?)endsolid/g;\r\n\t\t\tconst patternFace = /facet([\\s\\S]*?)endfacet/g;\r\n\t\t\tlet faceCounter = 0;\r\n\r\n\t\t\tconst patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source;\r\n\t\t\tconst patternVertex = new RegExp( 'vertex' + patternFloat + patternFloat + patternFloat, 'g' );\r\n\t\t\tconst patternNormal = new RegExp( 'normal' + patternFloat + patternFloat + patternFloat, 'g' );\r\n\r\n\t\t\tconst vertices = [];\r\n\t\t\tconst normals = [];\r\n\r\n\t\t\tconst normal = new Vector3();\r\n\r\n\t\t\tlet result;\r\n\r\n\t\t\tlet groupCount = 0;\r\n\t\t\tlet startVertex = 0;\r\n\t\t\tlet endVertex = 0;\r\n\r\n\t\t\twhile ( ( result = patternSolid.exec( data ) ) !== null ) {\r\n\r\n\t\t\t\tstartVertex = endVertex;\r\n\r\n\t\t\t\tconst solid = result[ 0 ];\r\n\r\n\t\t\t\twhile ( ( result = patternFace.exec( solid ) ) !== null ) {\r\n\r\n\t\t\t\t\tlet vertexCountPerFace = 0;\r\n\t\t\t\t\tlet normalCountPerFace = 0;\r\n\r\n\t\t\t\t\tconst text = result[ 0 ];\r\n\r\n\t\t\t\t\twhile ( ( result = patternNormal.exec( text ) ) !== null ) {\r\n\r\n\t\t\t\t\t\tnormal.x = parseFloat( result[ 1 ] );\r\n\t\t\t\t\t\tnormal.y = parseFloat( result[ 2 ] );\r\n\t\t\t\t\t\tnormal.z = parseFloat( result[ 3 ] );\r\n\t\t\t\t\t\tnormalCountPerFace ++;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\twhile ( ( result = patternVertex.exec( text ) ) !== null ) {\r\n\r\n\t\t\t\t\t\tvertices.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) );\r\n\t\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\t\t\t\t\t\tvertexCountPerFace ++;\r\n\t\t\t\t\t\tendVertex ++;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// every face have to own ONE valid normal\r\n\r\n\t\t\t\t\tif ( normalCountPerFace !== 1 ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the normal of face number ' + faceCounter );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// each face have to own THREE valid vertices\r\n\r\n\t\t\t\t\tif ( vertexCountPerFace !== 3 ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the vertices of face number ' + faceCounter );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfaceCounter ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst start = startVertex;\r\n\t\t\t\tconst count = endVertex - startVertex;\r\n\r\n\t\t\t\tgeometry.addGroup( start, count, groupCount );\r\n\t\t\t\tgroupCount ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\t\t\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\r\n\t\t\treturn geometry;\r\n\r\n\t\t}\r\n\r\n\t\tfunction ensureString( buffer ) {\r\n\r\n\t\t\tif ( typeof buffer !== 'string' ) {\r\n\r\n\t\t\t\treturn new TextDecoder().decode( buffer );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn buffer;\r\n\r\n\t\t}\r\n\r\n\t\tfunction ensureBinary( buffer ) {\r\n\r\n\t\t\tif ( typeof buffer === 'string' ) {\r\n\r\n\t\t\t\tconst array_buffer = new Uint8Array( buffer.length );\r\n\t\t\t\tfor ( let i = 0; i < buffer.length; i ++ ) {\r\n\r\n\t\t\t\t\tarray_buffer[ i ] = buffer.charCodeAt( i ) & 0xff; // implicitly assumes little-endian\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn array_buffer.buffer || array_buffer;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn buffer;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// start\r\n\r\n\t\tconst binData = ensureBinary( data );\r\n\r\n\t\treturn isBinary( binData ) ? parseBinary( binData ) : parseASCII( ensureString( data ) );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { STLLoader };\r\n"],
  "mappings": "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",
  "names": ["data"]
}
